# Что такое git
___Система контроля версий (VCS)___ - ПО для пошагового изменения файла, переключения между версиями файла, сегментирвоания файла.
* Полная история изменений каждого файла за длительный период. Это касается всех изменений, внесенных огромным количеством людей за долгие годы. Изменением считается создание и удаление файлов, а также редактирование их содержимого. Различные инструменты VCS отличаются тем, насколько хорошо они обрабатывают операции переименования и перемещения файлов. В историю также должны входить сведения об авторе, дата и комментарий с описанием цели каждого изменения. Наличие полной истории позволяет возвращаться к предыдущим версиям, чтобы проводить анализ основных причин возникновения ошибок и устранять проблемы в старых версиях программного обеспечения.
* Ветвление и слияние. Создание «веток» позволяет иметь несколько независимых друг от друга направлений разработки, а также выполнять их слияние, чтобы разработчики могли проверить, что изменения, внесенные в каждую из веток, не конфликтуют друг с другом. Многие команды разработчиков программного обеспечения создают отдельные ветки для каждой функциональной возможности, для каждого релиза либо и для того, и для другого.


# Подготовка репозитория
1.	Скачать и установить VS Code [отсюда](https://code.visualstudio.com/docs/?dv=win)
2.	Скачать и установить Git [по ссылке](https://git-scm.com/download/win)
3.	Проверить, работает ли git  с помощью команды 
git --version
4.	Добавить имя и email пользователя с помощью команд
  git config --global user.email "email@mail.com"
  git config --global user.name "User Name"


# Создание «сохранений»

**git add**

Команда `git add` добавляет изменение из рабочего каталога в раздел проиндексированных файлов. Она сообщает Git, что вы хотите включить изменения в конкретном файле в следующий коммит. Однако на самом деле команда `git add` не оказывает существенного влияния на репозиторий: изменения регистрируются в нем только после выполнения команды `git commit`.

    (здесь что-то умное по теме)
    Ошибки, конфликты, больше ошибок.

# Перемещение между сохранениями
Команда git checkout используется для переключения веток и выгрузки их содержимого в рабочий каталог.

Мы познакомились с этой командой в разделе Переключение веток главы 3 вместе с git branch.

В разделе Отслеживание веток главы 3 мы узнали как использовать флаг --track для отслеживания веток.

В разделе Использование команды checkout в конфликтах главы 7 мы использовали эту команду с опцией --conflict=diff3 для разрешения конфликтов заново, в случае если предыдущее решение не подходило по некоторым причинам.

Мы рассмотрели детали взаимосвязи этой команды и git reset в разделе Раскрытие тайн reset главы 7.

Мы исследовали внутренние механизмы этой команды в разделе HEAD главы 10. Информация [отсюда](https://git-scm.com/book/ru/v2/%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5-C%3A-%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-Git-%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F).

### Запись от себя.

Сохранив изменения, можно ввести команду ___git log___, которая выведет историю изменений с именами сохранений (строка начинается с "commit"). Чтобы переместиться между двумя имеющимися в репозитории сохранении, нужно ввести команду ___git checkout (первые 4 символа имени сохранения)___.

# Журнал изменений

### Взято [тут](https://git-scm.com/docs/git-log).

Shows the commit logs.

List commits that are reachable by following the parent links from the given commit(s), but exclude commits that are reachable from the one(s) given with a ^ in front of them. The output is given in reverse chronological order by default.

You can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with ^ in front are subtracted from that set. The remaining commits are what comes out in the command’s output. Various other options and paths parameters can be used to further limit the result.
Thus, the following command:

$ git log foo bar ^baz
means "list all the commits which are reachable from foo or bar, but not from baz".

A special notation "<commit1>..<commit2>" can be used as a short-hand for "^<commit1> <commit2>". For example, either of the following may be used interchangeably:

$ git log origin..HEAD
$ git log HEAD ^origin
Another special notation is "<commit1>…​<commit2>" which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:

$ git log A B --not $(git merge-base --all A B)
$ git log A...B
The command takes options applicable to the git-rev-list[1] command to control what is shown and how, and options applicable to the git-diff[1] command to control how the changes each commit introduces are shown.
### Инфа от себя.
Команда ___git log___ открывает журнал изменений, где указано, например:
commit ff9efc03fdc2b15bd83b2852c650d4072ce3445a - имя изменения, используя которое в команде ___git checkout___, можно переместиться в интересуемую версию репозитория.

Author: Роман Ахметов <roman3202@gmail.com> - имя автора, создавшего изменение.

Date:   Mon Oct 18 10:54:02 2021 +0300 - дата в время сохдания изменения.

# Ветки в git
### Инфа от себя.
При работе нескольких человек с репозиторием, полезно сегментировать изменения, которые хотят внести в файл участники. Для этого используется команда ___git branch___, выводящая список созданных веток, а команда ___git branch (название новой ветки)___ создаёт новую ветку. Важно помнить, что следует сохранять информацию во всех ветках.

# Слияние веток и решение конфликтов
### Взято [отсюда](https://webdevkin.ru/courses/git/git-merge).
Что такое мердж или слияние веток
Это перенос кода из одной ветки в другую. Например, когда мы заканчиваем работу над веткой, например, сделали новый функционал или поправили багу, мы сливаем ее в мастер. В мастере код проверяется еще раз и выкладывается на боевой сервер.

Сливать друг в друга можно любые ветки. Технически, с точки зрения git нет никакой разницы, сливается ветка с новым функционалом в мастер или наоборот. Для нас мастер - это основная ветка разработки, а для git это просто ветка.

Разница логическая

Мы будем говорить, что новая ветка сливается в мастер, когда мы закончили работать над функционалом и хотим выложить его на боевой сайт. Тогда мы сливаем ветку в мастер и выкладываем мастер в продакшен.

Мастер сливается в ветку или мастер подтягивается в ветку, когда мы продолжаем работать над веткой, но хотим периодически подтягивать новые коммиты с сервера - новый код, который написали наши коллеги. Если работа над веткой идет довольно долго, есть смысл подтягивать изменения из мастера хоть каждый день.

Следует четко различать мердж своей ветки в мастер и мердж мастера в свою ветку.

Мердж ветки в мастер
Выполняется после завершения работы над своей веткой при помощи команды git merge. Чтобы вмерджить ветку в мастер, нужно сначала перейти в мастер, а затем выполнить git merge branch_name.


    $ git checkout master
    $ git merge news
При этом возможны разные ситуации
Поговорим о них подробнее

Пока мы работали над веткой, в мастере не появилось новых коммитов
То есть мы создали ветку, поработали над ней, собрались заливать ее в мастер, а за это время новых коммитов там не появилось. Тогда слияние проходит так


    $ git merge news
    Updating f32b91e..33ea897
    Fast-forward
     index.html | 3 ++-
     1 file changed, 2 insertions(+), 1 deletion(-)
     
    $ git push origin master
    $ git branch -d news
Git понимает, что это новый код, который можно просто положить поверх старого. Это простая ситуация и git не задает никаких вопросов.

Не забудьте сразу запушить изменения, чтобы их увидели коллеги, и удалить локальную ветку header, если она больше не нужна.

Теперь другая ситуация.

Пока мы работали над веткой, в мастере появились коммиты от коллег
Сначала переключаемся на мастер


    $ git checkout master 
    Switched to branch 'master'
    Your branch is up-to-date with 'origin/master'.
Почему "is up-to-date"? Потому что мы еще не сделали git pull. Делаем


    $ git pull --rebase origin master 
Мерджим свою ветку в мастер


    $ git merge news-styles 
И не забываем запушить изменения


    $ git push origin master 
### Инфа от себя
Несколько сохраненных веток можно объединить, использовав команду ___git merge (имя ветки)___. Объединение надо выполнять, находясь в той ветке, в которую пользователь желает переместить другую ветку.

При этом, если текст в одних и тех же строках сливаемых веток отличается друг от друга, произойдёт *конфликт*. VSC выделит цветом конфликтующую строку и сверху предложит ссылки, ведущие к решению конфликта: оставить оба варианта, либо из одной из веток.

# Удаление веток
### Взято [отсюда](https://losst.ru/kak-udalit-vetku-git)
Прежде чем что-либо удалять необходимо посмотреть какие ветки у вас есть. Для того чтобы посмотреть локальные ветки используйте такую команду в папке с репозиторием:

git branch

Команда выведет список локальных веток, а текущая ветка будет выделена зеленым цветом и звездочкой. Для того чтобы удалить ветку необходимо использовать ту же команду branch с опцией -d. Например, для того чтобы удалить ветку feature/somefeature1 выполните такую команду:

git branch -d feature/somefeature1

Или:

git branch --delete feature/somefeature1

Если в этой ветке есть не зафиксированные изменения или коммиты, не отправленные на сервер, то программа может отказаться её удалять. Для того чтобы всё же удалить такую ветку используйте опцию -D:

git branch -D feature/somefeature1
Когда ветка перестала использоваться (например, после успешного слияния с основной), ветку "донор" можно удалить. Для этого используется команда ___git branch -d (название удаляемой ветки)___.

# Homework seminar 3
С помощью [GitHub](https://github.com/) можно из удаленного репозитория создать локальный. Для этого, находясь на странице нужного удаленного репозитория, можно открыть окно "Code", подсвеченное зелёным цветом, и скопировать HTTPS-ссылку в буфер обмена. Далее, создав папку для локального репозитория и открыв её в Visual Studio Code, создать репозиторий, введя команду в терминале ___git clone (скопированная ссылка)___. При выполнении git clone с сервера забирается каждая версия каждого файла из истории проекта. Иными словами, введя команду ___git log___, вы сможете увидеть все изменения, осуществленные с репозиторием.

Чтобы синронизировать локальный репозиторий с удаленным, когда в нём появились новые изменения, достаточно использовать команду ___git fetch___, которая связывается с удалённым репозиторием и забирает из него все изменения, которых на локальном репозитории пока нет и сохраняет их локально.

Команда ___git pull___ работает как комбинация команд git fetch и git merge, т.е. git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

Команда ___git push___ используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.